from __future__ import annotations
import re
from copy import deepcopy
from dataclasses import dataclass
from typing import Dict, Any, List, Tuple, Optional

import numpy as np
import pandas as pd
import plotly.graph_objects as go
import streamlit as st

st.set_page_config(page_title="DealDash – AI-Powered Deal Simulation", layout="wide")


BASELINE = {
    "company_name": "SampleCo",
    "revenue": 1_000_000_000.0,
    "ebitda": 200_000_000.0,
    "ebitda_margin_pct": 20.0,
    "d_and_a": 40_000_000.0,
    "net_debt": 300_000_000.0,
    "shares_out": 100_000_000.0,
    "ev_to_ebitda": 10.0,
    "interest_rate_pct": 6.0,
    "tax_rate_pct": 25.0,
}


def bps_to_pct(bps: float) -> float:
    return bps / 10_000.0

def clamp(x: float, lo: float, hi: float) -> float:
    return max(lo, min(hi, x))

def money(x: float) -> str:
    try:
        return f"${x:,.0f}"
    except Exception:
        return str(x)

def _fmt_for_log(v: Any) -> str:
    if v is None:
        return ""
    if isinstance(v, float):
        if abs(v) >= 1_000:
            return f"{v:,.0f}"
        s = f"{v:.4f}".rstrip("0").rstrip(".")
        return s if s else "0"
    return str(v)

def df_from_log(log: List[Tuple[str, str, Any, Any]]) -> pd.DataFrame:
    rows = []
    for i, (metric, formula, param, value) in enumerate(log, start=1):
        rows.append({
            "step": i,
            "metric": str(metric),
            "formula": str(formula),
            "param": _fmt_for_log(param),
            "value": _fmt_for_log(value),
        })
    df = pd.DataFrame(rows)
    return df.astype({
        "step": "int64",
        "metric": "string",
        "formula": "string",
        "param": "string",
        "value": "string",
    })


def parse_prompt_to_scenario(text: str) -> Dict[str, float]:
    s = text.lower()
    sc: Dict[str, float] = {}

    m = re.search(r"(?:ebitda\s+)?margin[^0-9+\-]*([+-]?\d+)\s*bps", s)
    if m:
        sc["ebitda_margin_bps"] = float(m.group(1))

    m = re.search(r"rate[s]?[^0-9+\-]*([+-]?\d+)\s*bps", s)
    if m:
        sc["rate_bps"] = float(m.group(1))

    m = re.search(r"(?:exit\s+)?multiple[^0-9+\-\.]*([+-]?\d+(?:\.\d+)?)x", s)
    if m:
        sc["exit_multiple_delta"] = float(m.group(1))

    m = re.search(r"revenue[^0-9+\-]*([+-]?\d+)\s*%", s)
    if m:
        sc["revenue_delta_pct"] = float(m.group(1)) / 100.0

    m = re.search(r"opex[^0-9+\-]*([+-]?\d+)\s*%", s)
    if m:
        sc["opex_delta_pct"] = float(m.group(1)) / 100.0

    if "ebitda_margin_bps" in sc:
        sc["ebitda_margin_bps"] = clamp(sc["ebitda_margin_bps"], -1000, 1000)
    if "rate_bps" in sc:
        sc["rate_bps"] = clamp(sc["rate_bps"], -2000, 2000)
    if "exit_multiple_delta" in sc:
        sc["exit_multiple_delta"] = clamp(sc["exit_multiple_delta"], -3.0, 3.0)
    if "revenue_delta_pct" in sc:
        sc["revenue_delta_pct"] = clamp(sc["revenue_delta_pct"], -0.5, 0.5)

    return sc


@dataclass
class Adjusted:
    revenue: float
    ebitda: float
    ebit: float
    interest: float
    ebt: float
    tax: float
    net_income: float
    exit_multiple: float
    ev: float
    rate: float

def apply_scenario(
    baseline: Dict[str, float],
    sc: Dict[str, float],
    tax_rate_override: Optional[float] = None
) -> Tuple[Dict[str, float], List[Tuple[str, str, Any, Any]]]:
    b = deepcopy(baseline)
    log: List[Tuple[str, str, Any, Any]] = []

    revenue_delta = sc.get("revenue_delta_pct", 0.0)
    revenue = b["revenue"] * (1 + revenue_delta)
    log.append(("revenue", "baseline × (1 + delta)", revenue_delta, revenue))

    base_margin = b["ebitda_margin_pct"] / 100.0
    margin = clamp(base_margin + bps_to_pct(sc.get("ebitda_margin_bps", 0.0)), 0.0, 0.8)
    ebitda = revenue * margin
    log.append(("ebitda", "revenue × margin", margin, ebitda))

    d_and_a = b["d_and_a"]
    ebit = ebitda - d_and_a
    log.append(("ebit", "ebitda - D&A", d_and_a, ebit))

    base_rate = b["interest_rate_pct"] / 100.0
    rate = max(0.0, base_rate + bps_to_pct(sc.get("rate_bps", 0.0)))
    interest = b["net_debt"] * rate
    log.append(("interest", "net_debt × rate", rate, interest))

    ebt = ebit - interest
    tax_rate = tax_rate_override if tax_rate_override is not None else b["tax_rate_pct"] / 100.0
    tax = max(0.0, ebt) * tax_rate
    net_income = ebt - tax
    log.append(("ebt", "ebit - interest", "", ebt))
    log.append(("tax", "max(0, ebt) × tax_rate", tax_rate, tax))
    log.append(("net_income", "ebt - tax", "", net_income))

    exit_mult = clamp(b["ev_to_ebitda"] + sc.get("exit_multiple_delta", 0.0), 0.1, 30.0)
    ev = ebitda * exit_mult
    log.append(("enterprise_value", "ebitda × exit_multiple", exit_mult, ev))

    adjusted_state = {
        **b,
        "revenue": revenue,
        "ebitda": ebitda,
        "ebit": ebit,
        "interest": interest,
        "ebt": ebt,
        "tax": tax,
        "net_income": net_income,
        "exit_multiple": exit_mult,
        "ev": ev,
        "tax_rate_pct": tax_rate * 100.0,
        "rate": rate,
    }
    return adjusted_state, log

def summarize_outputs(adjusted: Dict[str, float]) -> Dict[str, float]:
    equity_value = adjusted["ev"] - adjusted["net_debt"]
    per_share = equity_value / adjusted["shares_out"]
    return {
        "ev": adjusted["ev"],
        "equity_value": equity_value,
        "equity_per_share": per_share,
    }

def sensitivity_heatmap(baseline: Dict[str, float], x_var: str, x_values: List[float],
                        y_var: str, y_values: List[float]) -> go.Figure:
    z: List[List[float]] = []
    for y in y_values:
        row: List[float] = []
        for x in x_values:
            sc = {x_var: x, y_var: y}
            adj, _ = apply_scenario(baseline, sc)
            out = summarize_outputs(adj)
            row.append(float(out["equity_per_share"]))
        z.append(row)
    fig = go.Figure(data=go.Heatmap(z=z, x=x_values, y=y_values))
    fig.update_layout(xaxis_title=x_var, yaxis_title=y_var, margin=dict(l=0, r=0, t=10, b=0))
    return fig

def ev_bridge_figure(baseline: Dict[str, float], adjusted: Dict[str, float]) -> go.Figure:
    base_ebitda = baseline["ebitda"]
    base_mult = baseline["ev_to_ebitda"]
    base_ev = base_ebitda * base_mult
    new_ebitda = adjusted["ebitda"]
    new_mult = adjusted["exit_multiple"]
    new_ev = adjusted["ev"]

    contrib_ebitda = (new_ebitda - base_ebitda) * base_mult
    contrib_mult = new_ebitda * (new_mult - base_mult)
    interaction = new_ev - (base_ev + contrib_ebitda + contrib_mult)

    measure = ["absolute", "relative", "relative", "relative", "total"]
    labels = ["Baseline EV", "EBITDA Δ @ base multiple", "Multiple Δ @ new EBITDA", "Interaction", "Adjusted EV"]
    values = [base_ev, contrib_ebitda, contrib_mult, interaction, new_ev]

    fig = go.Figure(go.Waterfall(
        orientation="v",
        measure=measure,
        x=labels,
        text=[money(v) for v in values],
        y=values,
        connector={"line":{"width":1}}
    ))
    fig.update_layout(title="EV Bridge", margin=dict(l=0, r=0, t=30, b=10))
    return fig

def monte_carlo_equity_ps(baseline: Dict[str, float], tax_rate: float,
                          n: int = 2000,
                          rev_sigma_pct: float = 0.03,
                          margin_sigma_bps: float = 100.0,
                          rate_sigma_bps: float = 50.0,
                          mult_sigma: float = 0.3) -> np.ndarray:
    rng = np.random.default_rng(42)
    out = np.empty(n, dtype=float)
    for i in range(n):
        sc = {
            "revenue_delta_pct": rng.normal(0.0, rev_sigma_pct),
            "ebitda_margin_bps": rng.normal(0.0, margin_sigma_bps),
            "rate_bps": rng.normal(0.0, rate_sigma_bps),
            "exit_multiple_delta": rng.normal(0.0, mult_sigma),
        }
        adj, _ = apply_scenario(baseline, sc, tax_rate_override=tax_rate)
        summ = summarize_outputs(adj)
        out[i] = summ["equity_per_share"]
    return out

def narrative(baseline: Dict[str, float], scenario: Dict[str, float], outputs: Dict[str, float]) -> str:
    parts: List[str] = []
    if "ebitda_margin_bps" in scenario:
        parts.append(f"EBITDA margin change: {int(scenario['ebitda_margin_bps'])} bps.")
    if "rate_bps" in scenario:
        parts.append(f"Interest rate move: {int(scenario['rate_bps'])} bps.")
    if "exit_multiple_delta" in scenario:
        parts.append(f"Exit multiple delta: {scenario['exit_multiple_delta']:.1f}x.")
    if "revenue_delta_pct" in scenario:
        parts.append(f"Revenue change: {scenario['revenue_delta_pct']*100:.1f}%.")

    if not parts:
        parts.append("Assumptions unchanged.")
    parts.append(
        f"Result: EV {money(outputs['ev'])}, equity {money(outputs['equity_value'])}, "
        f"per-share {outputs['equity_per_share']:.2f}."
    )
    return " ".join(parts)


st.title("DealDash – AI-Powered Deal Simulation")

with st.sidebar:
    st.header("Assumptions")
    tax_rate_ui = st.slider("Tax rate (%)", 0, 50, int(BASELINE["tax_rate_pct"]))
    show_log = st.checkbox("Show calc log", value=True)
    st.divider()
    st.caption("Scenario presets")
    preset = st.selectbox(
        "Pick a preset",
        (
            "None",
            "Margins -200 bps; rates +50 bps; +0.5x multiple",
            "Revenue -5%; margins -100 bps",
            "Rates +150 bps; multiple -1.0x",
            "Revenue +3%; +1.0x multiple",
        ),
        index=0
    )

st.subheader("Baseline snapshot")
cA, cB, cC, cD = st.columns(4)
cA.metric("Revenue", money(BASELINE["revenue"]))
cB.metric("EBITDA margin", f"{BASELINE['ebitda_margin_pct']:.1f}%")
cC.metric("EV/EBITDA", f"{BASELINE['ev_to_ebitda']:.1f}x")
cD.metric("Net debt", money(BASELINE["net_debt"]))

st.subheader("Describe your what-if scenario")
def_prompt = "drop ebitda margin 300 bps and raise rates 50 bps; add 1.0x to exit multiple"
user_text = st.text_area("Type in plain English:", def_prompt)
if preset != "None":
    if "Margins -200 bps" in preset:
        user_text = "drop ebitda margin 200 bps and raise rates 50 bps; add 0.5x to exit multiple"
    elif "Revenue -5%" in preset:
        user_text = "revenue -5%; drop ebitda margin 100 bps"
    elif "Rates +150 bps" in preset:
        user_text = "raise rates 150 bps; multiple -1.0x"
    elif "Revenue +3%" in preset:
        user_text = "revenue +3%; add 1.0x to exit multiple"
    st.info(f"Preset applied: {user_text}")

if st.button("Run scenario"):
    scenario = parse_prompt_to_scenario(user_text)
    adjusted, log = apply_scenario(BASELINE, scenario, tax_rate_override=tax_rate_ui/100.0)
    outputs = summarize_outputs(adjusted)

    m1, m2, m3 = st.columns(3)
    m1.metric("Enterprise Value", money(outputs["ev"]))
    m2.metric("Equity Value", money(outputs["equity_value"]))
    m3.metric("Equity / Share", f"{outputs['equity_per_share']:.2f}")

    st.markdown("Sensitivity: equity per share vs. margin and multiple")
    x_vals = [-200, -100, 0, 100, 200]
    y_vals = [-1.0, -0.5, 0.0, 0.5, 1.0]
    st.plotly_chart(
        sensitivity_heatmap(BASELINE, "ebitda_margin_bps", x_vals, "exit_multiple_delta", y_vals),
        width='stretch'
    )

    st.subheader("EV bridge")
    st.plotly_chart(ev_bridge_figure(BASELINE, adjusted), width='stretch')

    st.subheader("Narrative")
    st.write(narrative(BASELINE, scenario, outputs))

    
    st.subheader("Leverage & Coverage (pro-forma)")
    colL, colR = st.columns([1,2])
    with colL:
        extra_debt = st.slider("Extra debt draw ($)", 0, 1_000_000_000, 0, step=25_000_000)
    pf_net_debt = adjusted["net_debt"] + extra_debt
    pf_interest = adjusted["interest"] + extra_debt * adjusted["rate"]
    leverage = (pf_net_debt / adjusted["ebitda"]) if adjusted["ebitda"] else np.nan
    coverage = (adjusted["ebitda"] / pf_interest) if pf_interest else np.nan

    c1, c2, c3 = st.columns(3)
    c1.metric("Rate (annual)", f"{adjusted['rate']*100:.2f}%")
    c2.metric("Net debt / EBITDA", f"{leverage:.2f}x")
    c3.metric("EBITDA / Interest", f"{coverage:.2f}x")

    pf_equity_value = adjusted["ev"] - pf_net_debt
    pf_equity_ps = pf_equity_value / adjusted["shares_out"]
    with colR:
        st.markdown("Pro-forma equity (after extra debt)")
        r1, r2 = st.columns(2)
        r1.metric("Equity Value", money(pf_equity_value))
        r2.metric("Equity / Share", f"{pf_equity_ps:.2f}")

        
    st.subheader("Cap Table (simple)")
    cc1, cc2, cc3, cc4 = st.columns([1, 1, 1, 1])
    with cc1:
        primary_raise = st.number_input("Primary raise ($)", min_value=0.0, value=0.0, step=1_000_000.0, format="%.0f")
    with cc2:
        default_px = max(0.01, float(pf_equity_ps))
        issue_px = st.number_input("Issue price ($/sh)", min_value=0.01, value=default_px, step=0.10, format="%.2f")
    with cc3:
        secondary_sell = st.number_input("Secondary sell ($)", min_value=0.0, value=0.0, step=1_000_000.0,
                                         format="%.0f")
    with cc4:
        option_pool_pct = st.slider("Option pool (% of post)", 0.0, 25.0, 10.0, 1.0) / 100.0

    use_primary_to_paydown = st.checkbox("Use primary proceeds to reduce net debt", value=True)

    pre_shares = BASELINE["shares_out"]
    new_shares = (primary_raise / issue_px) if issue_px > 0 else 0.0
    target_post_shares = (pre_shares + new_shares) / (1 - option_pool_pct) if option_pool_pct < 0.999 else (
                pre_shares + new_shares)
    pool_shares = max(0.0, target_post_shares - (pre_shares + new_shares))
    post_shares = pre_shares + new_shares + pool_shares

    pf_net_debt_final = pf_net_debt - (primary_raise if use_primary_to_paydown else 0.0)
    equity_value_post = adjusted["ev"] - pf_net_debt_final
    equity_ps_post = equity_value_post / post_shares if post_shares else np.nan

    t1, t2, t3 = st.columns(3)
    t1.metric("Post-money shares", f"{post_shares:,.0f}")
    t2.metric("Equity Value (post)", money(equity_value_post))
    t3.metric("Equity / Share (post)", f"{equity_ps_post:.2f}")

    founders_sh = pre_shares
    new_inv_sh = new_shares
    pool_sh = pool_shares

    owners = pd.DataFrame({
        "holder": ["Founders/Existing", "New Investors (Primary)", "Option Pool"],
        "shares": [founders_sh, new_inv_sh, pool_sh],
        "ownership_pct": [founders_sh / post_shares, new_inv_sh / post_shares,
                          pool_sh / post_shares] if post_shares else [np.nan] * 3
    })
    owners["ownership_pct"] = (owners["ownership_pct"] * 100).round(2)

    pie = go.Figure(data=[go.Pie(labels=owners["holder"], values=owners["shares"], hole=0.45)])
    pie.update_layout(title="Ownership (post)", margin=dict(l=0, r=0, t=30, b=0))
    st.plotly_chart(pie, width='stretch')

    st.dataframe(
        owners.assign(shares=owners["shares"].map(lambda x: f"{x:,.0f}")),
        width='stretch'
    )
    owners_csv = owners.to_csv(index=False).encode("utf-8")
    st.download_button("Download cap table (CSV)", owners_csv, file_name="dealdash_cap_table.csv", mime="text/csv")

    if secondary_sell > 0:
        st.caption(f"Secondary sell ($ {secondary_sell:,.0f}) goes to selling holders; does not change share count.")

   
    if show_log:
        st.subheader("Calculation log")
        df_log = df_from_log(log)
        st.dataframe(df_log, width='stretch')
        csv = df_log.to_csv(index=False).encode("utf-8")
        st.download_button("Download calc log (CSV)", csv, file_name="dealdash_calc_log.csv", mime="text/csv")

    st.divider()
    with st.expander("Monte Carlo (optional)"):
        mc_runs = st.slider("Simulations", 500, 5000, 2000, 500)
        rev_sigma = st.slider("Revenue σ (pct)", 0.0, 0.10, 0.03, 0.005)
        margin_sigma = st.slider("Margin σ (bps)", 0.0, 300.0, 100.0, 25.0)
        rate_sigma = st.slider("Rate σ (bps)", 0.0, 300.0, 50.0, 10.0)
        mult_sigma = st.slider("Multiple σ (x)", 0.0, 2.0, 0.3, 0.1)
        if st.button("Run Monte Carlo"):
            samples = monte_carlo_equity_ps(
                BASELINE, tax_rate_ui / 100.0, n=mc_runs,
                rev_sigma_pct=rev_sigma, margin_sigma_bps=margin_sigma,
                rate_sigma_bps=rate_sigma, mult_sigma=mult_sigma
            )
            hist = go.Figure(data=[go.Histogram(x=samples, nbinsx=40)])
            hist.update_layout(
                title="Equity per share distribution",
                xaxis_title="Equity per share",
                yaxis_title="Frequency",
                margin=dict(l=0, r=0, t=30, b=0)
            )
            st.plotly_chart(hist, width='stretch')

st.caption("This tutorial MVP is for education only. Numbers are illustrative, not investment advice.")

